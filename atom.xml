<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JiangLiang✨</title>
  
  
  <link href="https://jiangliang-7.github.io/atom.xml" rel="self"/>
  
  <link href="https://jiangliang-7.github.io/"/>
  <updated>2023-03-02T09:13:12.851Z</updated>
  <id>https://jiangliang-7.github.io/</id>
  
  <author>
    <name>JiangLiang✨</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java基础（三）</title>
    <link href="https://jiangliang-7.github.io/2023/03/02/java%E7%AC%94%E8%AE%B0%E4%B8%89/"/>
    <id>https://jiangliang-7.github.io/2023/03/02/java%E7%AC%94%E8%AE%B0%E4%B8%89/</id>
    <published>2023-03-02T09:07:09.343Z</published>
    <updated>2023-03-02T09:13:12.851Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="java基础（三）"><a href="#java基础（三）" class="headerlink" title="java基础（三）"></a>java基础（三）</h1><h2 id="一、this-关键字"><a href="#一、this-关键字" class="headerlink" title="一、this 关键字"></a>一、this 关键字</h2><ul><li>this 的注意事项和使用细节<ul><li>this 关键字可以用来访问本类的属性、方法、构造器</li><li>this 用于区分当前类的属性和局部变量</li><li>访问成员方法的语法：this.方法名(参数列表);</li><li>访问构造器语法：this(参数列表); 注意只能在构造器中使用(即==只能在构造器中访问另外一个构造器, 必须放在第一条语句)==</li><li>this 不能在类定义的外部使用，只能在类定义的方法中使用。</li></ul></li></ul><h2 id="二、访问修饰符"><a href="#二、访问修饰符" class="headerlink" title="二、访问修饰符"></a>二、访问修饰符</h2><ul><li><p>java 提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限（范围）:</p><ul><li>公开级别:用 public 修饰,对外公开</li><li>受保护级别:用 protected 修饰,对子类和同一个包中的类公开</li><li>默认级别:没有修饰符号,向同一个包的类公开.</li><li>私有级别:用 private 修饰,只有类本身可以访问,不对外公开.</li></ul></li><li><p>4 种访问修饰符的访问范围</p><ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301190431772.png" alt="image-20230301190431772"></li></ul></li><li><p>使用的注意事项</p><ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301191429104.png" alt="image-20230301191429104"></li></ul></li></ul><h2 id="三、面向对象编程三大特征"><a href="#三、面向对象编程三大特征" class="headerlink" title="三、面向对象编程三大特征"></a>三、面向对象编程三大特征</h2><ul><li><p>面向对象编程有三大特征：封装、继承和多态。</p></li><li><p>封装</p><ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301192102000.png" alt="image-20230301192102000"></li><li>封装的理解和好处<ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301192154981.png" alt="image-20230301192154981"></li></ul></li><li>实现步骤 (三步)<ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301192323526.png" alt="image-20230301192323526"></li></ul></li></ul></li><li><p>继承</p><ul><li>继承可以解决代码复用,让我们的编程更加靠近人类思维.当多个类存在相同的属性(变量)和方法时,可以从这些类中抽象出父类,在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过extends来声明继承父类即可。</li><li>继承的示意图<ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301194109007.png" alt="image-20230301194109007"></li></ul></li><li>继承的基本语法<ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301194152149.png" alt="image-20230301194152149"></li></ul></li><li>继承的使用细节<ul><li>子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访问，要通过父类提供公共的方法去访问</li><li>子类必须调用父类的构造器， 完成父类的初始化</li><li>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过</li><li>如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表)</li><li>super 在使用时，必须放在构造器第一行(super 只能在构造器中使用)</li><li>super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</li><li>java 所有类都是 Object 类的子类, Object 是所有类的基类.</li><li>父类构造器的调用不限于直接父类！将一直往上追溯直到 Object 类(顶级父类)</li><li>子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制。</li><li>不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系</li></ul></li></ul></li><li><p>多态（重点）</p><ul><li><p>方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。</p></li><li><p>使用案例</p><ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301211037921.png" alt="image-20230301211037921"></li></ul></li><li><p><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301204916628.png" alt="image-20230301204916628"></p></li><li><p><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301204938403.png" alt="image-20230301204938403"></p></li><li><p>多态注意事项和细节讨论</p><ul><li><p>多态的前提是：两个对象(类)存在继承关系</p></li><li><p>多态的向上转型</p><ul><li>比如 <code>Animal animal = new Dog()</code></li><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301205556479.png" alt="image-20230301205556479"></li><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301212554226.png" alt="image-20230301212554226"></li><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301212838376.png" alt="image-20230301212838376"></li><li>能调用哪些成员，由编译类型决定，所以不能调用子类中特有成员，但执行时，看的是运行类型</li></ul></li><li><p>多态的向下转型</p><ul><li><p><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301205640093.png" alt="image-20230301205640093"></p></li><li><p>```java<br>Animal animal = new Cat();//父类的引用指向猫类型的对象<br>Cat cat = (Cat) animal;//正确的向下转型<br>Dog dog = (Dog) animal;//错误的向下转型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 四、super 关键字</span><br><span class="line"></span><br><span class="line">- super 代表父类的引用，用于访问父类的属性、方法、构造器</span><br><span class="line">- 基本语法</span><br><span class="line">  - ![image-20230301202312360](https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301202312360.png)</span><br><span class="line">- super 给编程带来的便利/细节</span><br><span class="line">  - ![image-20230301203250275](https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301203250275.png)</span><br><span class="line">  - ![image-20230301203309439](https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301203309439.png)</span><br><span class="line">- super 和 this 的比较</span><br><span class="line">  - ![image-20230301203439395](https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301203439395.png)</span><br><span class="line"></span><br><span class="line">## 五、方法重写/覆盖(override)</span><br><span class="line"></span><br><span class="line">- ![image-20230301203614697](https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301203614697.png)</span><br><span class="line">- 注意事项和使用细节</span><br><span class="line">  - 方法重写也叫方法覆盖，需要满足下面的条件</span><br><span class="line">    - ![image-20230301204000912](https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301204000912.png)</span><br><span class="line">- 对方法的重写和重载做一个比较</span><br><span class="line">  - ![image-20230301204216798](https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301204216798.png)</span><br><span class="line"></span><br><span class="line">## 六、java 的动态绑定机制(非常非常重要.)</span><br><span class="line"></span><br><span class="line">- ![image-20230302103013416](https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230302103013416.png)</span><br><span class="line"></span><br><span class="line">## 七、Object 类详解</span><br><span class="line"></span><br><span class="line">- equals 方法</span><br><span class="line"></span><br><span class="line">  - ==和 equals 的对比 [面试题]</span><br><span class="line"></span><br><span class="line">    - ![image-20230302112204388](https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230302112204388.png)</span><br><span class="line">    - ![image-20230302112235175](https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230302112235175.png)</span><br><span class="line"></span><br><span class="line">  - 重写equals 方法</span><br><span class="line"></span><br><span class="line">    - 例子：</span><br><span class="line"></span><br><span class="line">    - ```java</span><br><span class="line">      //重写 Object 的 equals 方法</span><br><span class="line">          public boolean equals(Object obj) &#123;</span><br><span class="line">              //判断如果比较的两个对象是同一个对象，则直接返回 true</span><br><span class="line">              if (this == obj) &#123;</span><br><span class="line">                  return true;</span><br><span class="line">              &#125;</span><br><span class="line">              //类型判断</span><br><span class="line">              if (obj instanceof Person) &#123;//是 Person，我们才比较</span><br><span class="line">                  //进行 向下转型, 因为我需要得到 obj 的 各个属性</span><br><span class="line">                  Person p = (Person)obj;</span><br><span class="line">                  return this.name.equals(p.name) &amp;&amp; this.age == p.age &amp;&amp; this.gender == p.gender;</span><br><span class="line">              &#125;</span><br><span class="line">              //如果不是 Person ，则直接返回 false</span><br><span class="line">              return false;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p>hashCode 方法</p><ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230302114912056.png" alt="image-20230302114912056"></li><li>小结：<ul><li>提高具有哈希结构的容器的效率！</li><li>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！</li><li>两个引用，如果指向的是不同对象，则哈希值是不一样的</li><li>哈希值主要根据地址号来的！， 不能完全将哈希值等价于地址。</li></ul></li></ul></li><li><p>toString 方法</p><ul><li>基本介绍<ul><li>默认返回：全类名+@+哈希值的十六进制</li><li>子类往往重写 toString 方法，用于返回对象的属性信息</li></ul></li><li>重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式.</li><li>当直接输出一个对象时，toString 方法会被默认的调用, 比如 System.out.println(monster)；就会默认调用monster.toString()</li></ul></li><li><p>finalize 方法</p><ul><li>老韩提示： 我们在实际开发中，几乎不会运用 finalize , 所以更多就是为了应付面试.<ul><li>当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作</li><li>什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用 finalize 方法。</li><li>垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 也可以通过 System.gc() 主动触发垃圾回收机制</li></ul></li></ul></li></ul><h2 id="八、断点调试-debug"><a href="#八、断点调试-debug" class="headerlink" title="八、断点调试(debug)"></a>八、断点调试(debug)</h2><ul><li><p>介绍</p><ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230302130057971.png" alt="image-20230302130057971"></li></ul></li><li><p>快捷键</p><ul><li>F7(跳入)</li><li>F8(跳过)</li><li>shift+F8(跳出)</li><li>F9(resume,执行到下一个断点)</li><li>F7：跳入方法内 F8: 逐行执行代码.</li><li>shift+F8: 跳出方法</li></ul></li></ul><h2 id="九、类变量"><a href="#九、类变量" class="headerlink" title="九、类变量"></a>九、类变量</h2><ul><li>介绍<ul><li>类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。</li></ul></li><li>定义<ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230302133323078.png" alt="image-20230302133323078"></li></ul></li><li>访问<ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230302133457506.png" alt="image-20230302133457506"></li></ul></li><li>使用注意事项和细节<ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230302134407423.png" alt="image-20230302134407423"></li><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230302134429363.png" alt="image-20230302134429363"></li></ul></li></ul><h2 id="十、类方法"><a href="#十、类方法" class="headerlink" title="十、类方法"></a>十、类方法</h2><ul><li>调用<ul><li>使用方式：类名.类方法名 or 对象名.类方法名</li></ul></li><li>使用场景<ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230302161941104.png" alt="image-20230302161941104"></li></ul></li><li>注意事项和细节讨论<ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230302162251225.png" alt="image-20230302162251225"></li><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230302162307117.png" alt="image-20230302162307117"></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="java笔记" scheme="https://jiangliang-7.github.io/categories/java%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://jiangliang-7.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java基础（二）</title>
    <link href="https://jiangliang-7.github.io/2023/03/02/java%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <id>https://jiangliang-7.github.io/2023/03/02/java%E7%AC%94%E8%AE%B0%E4%BA%8C/</id>
    <published>2023-03-02T09:07:09.341Z</published>
    <updated>2023-03-02T09:26:18.477Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java基础（二）"><a href="#Java基础（二）" class="headerlink" title="Java基础（二）"></a>Java基础（二）</h1><h2 id="一、原码、反码、补码-重点-难点"><a href="#一、原码、反码、补码-重点-难点" class="headerlink" title="一、原码、反码、补码(重点 难点)"></a>一、原码、反码、补码(重点 难点)</h2><ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228184900573.png" alt="image-20230228184900573"></li></ul><h2 id="二、位运算符"><a href="#二、位运算符" class="headerlink" title="二、位运算符"></a><strong>二、位运算符</strong></h2><ul><li>java 中有 7 个位运算(&amp;、|、 ^ 、~、&gt;&gt;、&lt;&lt;和 &gt;&gt;&gt;)<ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228185556599.png" alt="image-20230228185556599"></li></ul></li><li>还有 3 个位运算符 &gt;&gt;、&lt;&lt; 和 &gt;&gt;&gt; , 运算规则:<ul><li> 算术右移 &gt;&gt;：低位溢出,符号位不变,并用符号位补溢出的高位 </li><li>15 &gt;&gt; 2 即右移两位，15 / 2 / 2 = 3，结果符号不变</li><li> 算术左移 &lt;&lt;: 符号位不变,低位补 0</li><li>15 &lt;&lt; 2 即左移两位，15 * 2 * 2 = 60，结果符号不变</li><li><code>&gt;&gt;&gt;</code>逻辑右移也叫无符号右移,运算规则是: 低位溢出，高位补 0<ul><li> <img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228194401033.png" alt="image-20230228194401033"></li></ul></li><li> 特别说明：没有 &lt;&lt;&lt; 符号</li></ul></li></ul><h2 id="三、循环部分重要的点"><a href="#三、循环部分重要的点" class="headerlink" title="三、循环部分重要的点"></a>三、循环部分重要的点</h2><ul><li><p>switch 注意事项和细节讨论</p><ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228200631343.png" alt="image-20230228200631343"></li></ul></li><li><p>do..while</p><ul><li>基本语法<ul><li>循环变量初始化;</li><li> do{ </li><li>循环体(语句);</li><li> 循环变量迭代; </li><li>}while(循环条件);</li></ul></li><li>老韩说明:<ul><li>do while 是关键字 </li><li>也有循环四要素, 只是位置不一样 </li><li>先执行，再判断，也就是说，一定会至少执行一次</li><li>最后 有一个 分号 ;</li></ul></li><li>注意事项和细节说明 <ul><li> 循环条件是返回一个布尔值的表达式 </li><li> do..while 循环是先执行，再判断，因此它至少执行一次</li></ul></li></ul></li><li><p>break</p><ul><li>注意事项和细节说明<ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228202745872.png" alt="image-20230228202745872"></li></ul></li></ul></li><li><p>continue</p><ul><li>continue 语句用于结束本次循环，继续执行下一次循环。</li><li>continue 语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环, 这个和前面的标签的使用的规则一样.</li></ul></li></ul><h2 id="四、数组的使用"><a href="#四、数组的使用" class="headerlink" title="四、数组的使用"></a>四、数组的使用</h2><ul><li><p><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228203802475.png" alt="image-20230228203802475"></p><ul><li>即 int a[] = new int[5]; 或者 int[] a = new int[5];</li></ul></li><li><p>使用方式 2：动态初始化</p><ul><li>先声明数组 <ul><li>语法:数据类型 数组名[]; 也可以 数据类型[] 数组名; </li><li>int a[]; 或者 int[] a;</li></ul></li><li>创建数组 <ul><li>语法: 数组名=new 数据类型[大小]; </li><li>a=new int[10];</li></ul></li></ul></li><li><p>使用方式 3: 静态初始化</p><ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228204625677.png" alt="image-20230228204625677"></li></ul></li><li><p>数组使用注意事项和细节</p><ul><li> 数组是多个相同类型数据的组合，实现对这些数据的统一管理 </li><li> 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。 </li><li>数组创建后，如果没有赋值，有默认值 int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \u0000，boolean false，String null </li><li> 使用数组的步骤 1. 声明数组并开辟空间 2 给数组各个元素赋值 3 使用数组 </li><li> 数组的下标是从 0 开始的。 </li><li> 数组下标必须在指定范围内使用，否则报：下标越界异常，比如 韩顺平循序渐进学Java 零基础第148页int [] arr=new int[5]; 则有效下标为 0-4 </li><li> 数组属引用类型，数组型数据是对象(object)</li></ul></li><li><p>数组赋值机制 </p><ul><li><p>基本数据类型赋值，这个值就是具体的数据，而且相互不影响。</p><ul><li>int n1 = 2; int n2 = n1; </li></ul></li><li><p>数组在默认情况下是引用传递，赋的值是地址。</p></li></ul></li><li><p>冒泡排序</p><ul><li><p><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228210323870.png" alt="image-20230228210323870"></p></li><li><p>```Java<br>//对数组进行冒泡排序</p><pre><code>for(int i = 0; i &lt; len-1;i++)//len-1次循环，将最大数到第len-1大的数往后排&#123;    for(int j = 0;j &lt; len-1-i;j++)    &#123;        int temp = 0;        if(str[j]&gt;str[j+1])        &#123;            temp = str[j+1];            str[j+1] = str[j];            str[j] = temp;        &#125;    &#125;&#125;</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 查找</span><br><span class="line"></span><br><span class="line">  - 在 java 中，我们常用的查找有两种:</span><br><span class="line">    -  顺序查找(用循环一个个找)</span><br><span class="line">    - 二分查找 </span><br><span class="line"></span><br><span class="line">- 二维数组</span><br><span class="line"></span><br><span class="line">  - 动态初始化 使用方式 1: </span><br><span class="line"></span><br><span class="line">    - ```Java</span><br><span class="line">      int a[][] = new int[2][3]</span><br><span class="line">      int[][] a = new int[2][3]</span><br><span class="line">      int[] a[] = new int[2][3]</span><br></pre></td></tr></table></figure></li><li><p>动态初始化 使用方式 2: </p><ul><li><p>先声明：类型 数组名[][];</p></li><li><p>再定义(开辟空间) 数组名 = new 类型<code>[大小][大小] </code>赋值(有默认值，比如 int 类型的就是 0</p></li><li><p>```java<br>int a[][];<br>a = new int[2][3];</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- 动态初始化 使用方式 3-列数不确定:</span><br><span class="line">  - ![image-20230301104333347](https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301104333347.png)</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    int[][] arr = new int[3][];</span><br><span class="line">    for(int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] = new int[i + 1];//给每一行开辟空间</span><br><span class="line">        for(int j = 0; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">    arr[i][j] = i + 1;//给每一行赋值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //遍历二维数组arr</span><br><span class="line">    for(int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    //输出 arr 的每个一维数组</span><br><span class="line">    for(int j = 0; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">    System.out.print(arr[i][j] + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();//换行</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>二维数组在内存的存在形式</p></li><li><p><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228212701710.png" alt="image-20230228212701710"></p></li><li><p>静态初始化 使用方式4:</p><ul><li><code>定义 类型 数组名[][] = &#123;&#123;值 1,值 2..&#125;,&#123;值 1,值 2..&#125;,&#123;值 1,值 2..&#125;&#125;;</code><ul><li>比如: </li><li><code>int[][] arr = &#123;&#123;1,1,1&#125;, &#123;8,8,9&#125;, &#123;100&#125;&#125;;</code></li></ul></li></ul></li></ul></li></ul><h2 id="五、类和对象"><a href="#五、类和对象" class="headerlink" title="五、类和对象"></a>五、类和对象</h2><ul><li><p>对象在内存中存在形式(重要的)</p><ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301150536632.png" alt="image-20230301150536632"></li></ul></li><li><p>成员变量 = 属性 = field(字段)</p><ul><li>属性的定义语法同变量<ul><li>示例：访问修饰符 属性类型 属性名;</li></ul></li><li>属性的定义类型可以为任意类型，包含基本类型或引用类型</li><li>属性如果不赋值，有默认值，规则和数组一致。具体说: int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \u0000，boolean false，String null</li></ul></li><li><p>创建对象</p><ul><li><p>直接创建</p><ul><li>```java<br>Cat cat = new Cat();<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 先声明再创建 </span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    Cat cat ; </span><br><span class="line">    cat = new Cat();</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>访问属性</p><ul><li><p>对象名.属性名;</p><ul><li><p>```java<br>cat.name;<br>cat.age;<br>cat.color;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 类和对象的内存分配机制</span><br><span class="line">  - ![image-20230301152034639](https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301152034639.png)![image-20230301152108709](https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301152108709.png)</span><br><span class="line"></span><br><span class="line">- Java 内存的结构分析</span><br><span class="line"></span><br><span class="line">  - 栈： 一般存放基本数据类型(局部变量) </span><br><span class="line">  - 堆： 存放对象(Cat cat , 数组等) </span><br><span class="line">  - 方法区：常量池(常量，比如字符串)， 类加载信息</span><br><span class="line"></span><br><span class="line">- Java 创建对象的流程简单分析</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    Person p = new Person();</span><br><span class="line">    p.name = “jack”;</span><br><span class="line">    p.age = 10;</span><br></pre></td></tr></table></figure></li><li><p>先加载 Person 类信息(属性和方法信息, 只会加载一次) </p></li><li><p>在堆中分配空间, 进行默认初始化(看规则) </p></li><li><p>把地址赋给 p , p 就指向对象</p></li><li><p>进行指定初始化， 比如 <code>p.name =”jack” p.age = 10</code></p></li></ul></li></ul></li><li><p>方法的调用机制原理：(重要!-示意图!!!)</p><ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301153548962.png" alt="image-20230301153548962"></li></ul></li><li><p>成员方法的好处</p><ul><li>提高代码的复用性</li><li>可以将实现的细节封装起来，然后供其他用户来调用即可</li></ul></li><li><p>成员方法的定义</p><ul><li>```java<br>访问修饰符 返回数据类型 方法名（形参列表..） {//方法体<pre><code>语句；return 返回值;</code></pre>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 访问修饰符 (作用是控制 方法使用的范围)</span><br><span class="line">  - 返回数据类型</span><br><span class="line">    - 一个方法最多有一个返回值</span><br><span class="line">    - 返回类型可以为任意类型，包含基本类型或引用类型(数组，对象)</span><br><span class="line">    - 如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值; 而且要求返回值类型必须和return的值类型一致或兼容</span><br><span class="line">    - 如果方法是 void，则方法体中可以没有 return 语句，或者 只写 return ;</span><br><span class="line">  - 方法名</span><br><span class="line">    - 遵循驼峰命名法，最好见名知义，表达出该功能的意思即可, 比如 得到两个数的和 getSum</span><br><span class="line">  - 形参列表、方法体</span><br><span class="line">    - ![image-20230301155044054](https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301155044054.png)</span><br><span class="line">  - 方法调用细节</span><br><span class="line">    - ![image-20230301155249540](https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301155249540.png)</span><br><span class="line"></span><br><span class="line">- 成员方法传参机制(非常非常重要)</span><br><span class="line">  - 基本数据类型的传参机制</span><br><span class="line">    - 形参的任何改变不影响实参</span><br><span class="line">  - 引用数据类型的传参机制</span><br><span class="line">    - 形参的改变会影响实参，引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参！</span><br><span class="line">    - B 类中编写一个方法 test100，可以接收一个数组，在方法中修改该数组，看看原来的数组是否变化？==会变化==</span><br><span class="line">    - B 类中编写一个方法 test200，可以接收一个 Person(age,sal)对象，在方法中修改该对象属性，看看原来的对象是否变化？==会变化==.</span><br><span class="line"></span><br><span class="line">## 六、方法**递归调用**(非常非常重要)</span><br><span class="line"></span><br><span class="line">- 简单的说: 递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂问题,同时可以让代码变得简洁</span><br><span class="line">- ==需要重新回顾==</span><br><span class="line"></span><br><span class="line">## 七、方法重载</span><br><span class="line"></span><br><span class="line">- Java 中允许同一个类中，多个同名方法的存在，但要求 形参列表不一致！</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    calculate(int n1, int n2) //两个整数的和</span><br><span class="line">    calculate(int n1, double n2) //一个整数，一个 double 的和</span><br><span class="line">    calculate(double n2, int n1)//一个 double ,一个 Int 和</span><br><span class="line">    calculate(int n1, int n2,int n3)//三个 int 的和</span><br></pre></td></tr></table></figure></li></ul></li><li><p>重载的好处</p><ul><li>减轻了起名的麻烦</li><li>减轻了记名的麻烦</li></ul></li><li><p>注意事项和使用细节</p><ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301162439079.png" alt="image-20230301162439079"></li></ul></li></ul><h2 id="八、可变参数"><a href="#八、可变参数" class="headerlink" title="八、可变参数"></a>八、可变参数</h2><ul><li><p>Java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。 就可以通过可变参数实现</p></li><li><p>基本语法</p><ul><li><p>```java<br>访问修饰符 返回类型 方法名(数据类型… 形参名) {<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 案例</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    //计算 2 个数的和，3 个数的和 ， 4. 5， 。。</span><br><span class="line">    class HspMethod &#123;</span><br><span class="line">    //使用方法重载</span><br><span class="line">    public int sum(int n1, int n2) &#123;//2 个数的和</span><br><span class="line">    return n1 + n2;</span><br><span class="line">    &#125;</span><br><span class="line">    public int sum(int n1, int n2, int n3) &#123;//3 个数的和</span><br><span class="line">    return n1 + n2 + n3;</span><br><span class="line">    &#125;</span><br><span class="line">    public int sum(int n1, int n2, int n3, int n4) &#123;//4 个数的和</span><br><span class="line">    return n1 + n2 + n3 + n4;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>```java<br>//1. int… 表示接受的是可变参数，类型是 int ,即可以接收多个 int(0-多)<br>//2. 使用可变参数时，可以当做数组来使用 即 nums 可以当做数组<br>//3. 遍历 nums 求和即可<br>public int sum(int… nums) {<pre><code>//System.out.println(&quot;接收的参数个数=&quot; + nums.length);int res = 0;for(int i = 0; i &lt; nums.length; i++) &#123;    res += nums[i];&#125;return res;</code></pre>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 注意事项和使用细节</span><br><span class="line">  - ![image-20230301164909801](https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301164909801.png)</span><br><span class="line"></span><br><span class="line">## 九、作用域</span><br><span class="line"></span><br><span class="line">- 基本使用（注意第四点）</span><br><span class="line">  - ![image-20230301165806629](https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301165806629.png)</span><br><span class="line"></span><br><span class="line">- 注意事项和细节使用</span><br><span class="line">  - ![image-20230301170629440](https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301170629440.png)</span><br><span class="line">  - ![image-20230301170700035](https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301170700035.png)</span><br><span class="line"></span><br><span class="line">## 十、构造方法/构造器</span><br><span class="line"></span><br><span class="line">- 构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    //当我们 new 一个对象时，直接通过构造器指定名字和年龄</span><br><span class="line">    Person p1 = new Person(&quot;smith&quot;, 80);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>基本语法</p><ul><li><pre><code class="Java">[修饰符] 方法名(形参列表)&#123;    方法体;&#125;</code></pre></li></ul></li><li><p>说明：</p><ul><li>构造器的修饰符可以默认， 也可以是 public、protected、private。</li><li>构造器没有返回值</li><li>方法名 和类名字必须一样</li><li>参数列表 和 成员方法一样的规则</li><li>在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。</li></ul></li><li><p>注意事项和使用细节</p><ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301172116088.png" alt="image-20230301172116088"></li><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230301172401898.png" alt="image-20230301172401898"></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="java笔记" scheme="https://jiangliang-7.github.io/categories/java%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://jiangliang-7.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java基础（一）</title>
    <link href="https://jiangliang-7.github.io/2023/03/02/java%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>https://jiangliang-7.github.io/2023/03/02/java%E7%AC%94%E8%AE%B0%E4%B8%80/</id>
    <published>2023-03-02T09:07:09.338Z</published>
    <updated>2023-03-02T09:13:43.073Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="java基础（一）"><a href="#java基础（一）" class="headerlink" title="java基础（一）"></a>java基础（一）</h1><h2 id="一、JDK、JRE-和-JVM-的包含关系"><a href="#一、JDK、JRE-和-JVM-的包含关系" class="headerlink" title="一、JDK、JRE 和 JVM 的包含关系"></a>一、JDK、JRE 和 JVM 的包含关系</h2><ol><li>JDK = JRE + 开发工具集（例如 Javac,java 编译工具等) </li><li>JRE = JVM + Java SE 标准类库（java 核心类库） </li><li>如果只想运行开发好的 .class 文件 只需要 JRE</li></ol><h2 id="二、程序中-号的使用"><a href="#二、程序中-号的使用" class="headerlink" title="二、程序中 +号的使用"></a>二、程序中 +号的使用</h2><ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230227150708469.png" alt="image-20230227150708469"></li></ul><h2 id="三、数据类型"><a href="#三、数据类型" class="headerlink" title="三、数据类型"></a>三、数据类型</h2><ul><li><p><strong>每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间(字节)。</strong></p><ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230227151035733.png" alt="image-20230227151035733"></li><li><strong>上图说明</strong> </li><li>java 数据类型分为两大类 ==基本数据类型==， ==引用类型== </li><li>基本数据类型有 8 中 数值型 [byte , short , int , long , float ,double] char , boolean</li><li>引用类型 [类，接口， 数组]</li></ul></li><li><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230227152928683.png" alt="image-20230227152928683"></li><li><strong>整形使用细节（注意第二点）</strong></li><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230227153029076.png" alt="image-20230227153029076"></li></ul></li><li><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230227153331868.png" alt="image-20230227153331868"></li><li><strong>说明</strong></li><li>关于浮点数在机器中存放形式的简单说明,浮点数=符号位+指数位+尾数位 </li><li>尾数部分可能丢失，造成精度损失(小数都是近似值)。</li><li><strong>浮点型使用细节</strong></li><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228104913338.png" alt="image-20230228104913338"></li></ul></li><li><h2 id="char类型"><a href="#char类型" class="headerlink" title="char类型"></a>char类型</h2><ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228111743739.png" alt="image-20230228111743739"></li></ul></li></ul><h2 id="四、字符编码表"><a href="#四、字符编码表" class="headerlink" title="四、字符编码表"></a>四、字符编码表</h2><ul><li><p> <strong>ASCII 码介绍(了解)</strong></p></li><li><p><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228111917807.png" alt="image-20230228111917807"></p></li><li><p><strong>Unicode 编码介绍(了解)</strong></p><ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228111947088.png" alt="image-20230228111947088"></li></ul></li><li><p><strong>UTF-8 编码介绍(了解)</strong></p><ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228112004942.png" alt="image-20230228112004942"></li></ul></li></ul><h2 id="五、基本数据类型转换"><a href="#五、基本数据类型转换" class="headerlink" title="五、基本数据类型转换"></a>五、基本数据类型转换</h2><ul><li><p><strong>自动类型转换</strong></p><ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228113418335.png" alt="image-20230228113418335"></li><li>自动类型转换注意和细节</li><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228113514906.png" alt="image-20230228113514906"></li></ul></li><li><p><strong>强制类型转换</strong></p><ul><li>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符( )，但可能造成精度降低或溢出,格外要注意。</li><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228114236079.png" alt="image-20230228114236079"></li><li><strong>强制类型转换细节说明</strong></li><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228115856024.png" alt="image-20230228115856024"></li></ul></li></ul><h2 id="六、基本数据类型和-String-类型的转换"><a href="#六、基本数据类型和-String-类型的转换" class="headerlink" title="六、基本数据类型和 String 类型的转换"></a>六、<strong>基本数据类型和 String 类型的转换</strong></h2><ul><li><p><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228144547822.png" alt="image-20230228144547822"></p></li><li><p><strong>注意事项</strong></p><ul><li>在将 String 类型转成 基本数据类型时，比如我们可以把”123” , 转成一个整数，但是不能把 “hello” 转成一个整数</li><li>如果格式不正确，就会抛出异常，程序就会终止</li></ul></li></ul><h2 id="七、运算符"><a href="#七、运算符" class="headerlink" title="七、运算符"></a>七、运算符</h2><ul><li><strong>运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。</strong></li></ul><ol><li>算术运算符</li><li>赋值运算符</li><li>关系运算符 [比较运算符] </li><li>逻辑运算符</li><li>位运算符 [需要二进制基础] </li><li>三元运算符</li></ol><ul><li><strong>算术运算符</strong><ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228145528096.png" alt="image-20230228145528096"></li><li><strong>细节说明</strong></li><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228145952989.png" alt="image-20230228145952989"></li><li><strong>面试题</strong></li><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228150123890.png" alt="image-20230228150123890"></li></ul></li><li><strong>关系运算符</strong><ul><li>关系运算符的结果都是 boolean 型，也就是要么是 true，要么是 false </li><li>关系表达式 经常用在 if 结构的条件中或循环结构的条件中</li><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228150713452.png" alt="image-20230228150713452"></li></ul></li><li><strong>逻辑运算符</strong><ul><li>用于连接多个条件（多个关系表达式），最终的结果也是一个 boolean 值。</li><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228151126276.png" alt="image-20230228151126276"></li><li><strong>说明逻辑运算规则</strong></li><li> &amp; 叫==逻辑与==、 &amp;&amp; 叫==短路与==：当 a 和 b 同时为 true ,则结果为 true, 否则为 false</li><li>| 叫==逻辑或==、|| 叫==短路或==：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false</li><li>!a : 叫取反，或者非运算。当 a 为 true, 则结果为 false, 当 a 为 false 是，结果为 true</li><li>a^b: 叫逻辑异或，当 a 和 b 不同时，则结果为 true, 否则为 false</li><li><strong>&amp;&amp; 和 &amp; 使用区别</strong></li><li>&amp;&amp;短路与：如果第一个条件为 false，则第二个条件不会判断，最终结果为 false，效率高</li><li>&amp; 逻辑与：不管第一个条件是否为 false，第二个条件都要判断，效率低</li><li>开发中， 我们使用的基本是使用短路与&amp;&amp;, 效率高</li><li><strong>|| 和 | 使用区别</strong></li><li>||短路或：如果第一个条件为 true，则第二个条件不会判断，最终结果为 true，效率高</li><li>| 逻辑或：不管第一个条件是否为 true，第二个条件都要判断，效率低</li><li>开发中，我们基本使用 ||</li></ul></li><li><strong>赋值运算符</strong><ul><li>赋值运算符就是将某个运算后的值，赋给指定的变量。</li><li>基本赋值运算符 = int a = 10;</li><li>+= ，-= ，*= ， /= ，%= 等 , 重点讲解一个 += ，其它的使用是一个道理<ul><li> a += b; [等价 a = a + b; ] </li><li>a -= b; [等价 a = a - b; ]</li></ul></li></ul></li></ul><ul><li><p><strong>三元运算符</strong></p><ul><li>基本语法<ul><li>条件表达式 ? 表达式 1: 表达式 2;</li></ul></li><li>运算规则：<ul><li>如果条件表达式为 true，运算后的结果是表达式 1； </li><li> 如果条件表达式为 false，运算后的结果是表达式 2；</li></ul></li><li>使用细节：<ul><li>表达式 1 和表达式 2 要为可以赋给接收变量的类型(或可以自动转换)</li><li>三元运算符可以转成 if–else 语句</li><li>int res = a &gt; b ? a++ : –b; </li><li>if ( a &gt; b) res = a++; </li><li>else res = –b;</li></ul></li></ul></li><li><p><strong>运算符优先级</strong></p><ul><li>运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。如右表，上一行运算符总优先于下一行。</li><li>只有单目运算符、赋值运算符是从右向左运算的。</li><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228162938536.png" alt="image-20230228162938536"></li></ul></li></ul><h2 id="八、标识符的命名规则和规范"><a href="#八、标识符的命名规则和规范" class="headerlink" title="八、标识符的命名规则和规范"></a><strong>八、标识符的命名规则和规范</strong></h2><ul><li><p><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228163943891.png" alt="image-20230228163943891"></p></li><li><p><strong>标识符命名规范[更加专业]</strong></p><ul><li> <strong>包名：</strong>多单词组成时所有字母都小写：aaa.bbb.ccc //比如 com.hsp.crm </li><li><strong>类名、接口名：</strong>多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰] 比如： TankShotGame </li><li><strong>变量名、方法名：</strong>多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz[小驼峰， 简称 驼峰法] 比如： tankShotGame </li><li><strong>常量名：</strong>所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ 比如 ：定义一个所得税率 TAX_RATE </li><li>后面我们学习到 类，包，接口，等时，我们的命名规范要这样遵守,更加详细的看文档.</li></ul></li><li><p><strong>关键字</strong></p><ul><li>关键字的定义和特点 (不用背) <ul><li>定义：被 Java 语言赋予了特殊含义，用做专门用途的字符串（单词） </li><li>特点：关键字中所有字母都为小写</li><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228164447900.png" alt="image-20230228164447900"><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228164539743.png" alt="image-20230228164539743"></li></ul></li></ul></li><li><p><strong>保留字</strong></p><ul><li>现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字 byValue、cast、future、 generic、 inner、 operator、 outer、 rest、 var 、 goto 、const</li></ul></li></ul><h2 id="九、键盘输入"><a href="#九、键盘输入" class="headerlink" title="九、键盘输入"></a>九、键盘输入</h2><ul><li>在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取，需要一个扫描器(对象), 就是Scanner</li><li><strong>步骤</strong><ul><li>导入该类的所在包,<ul><li>import java.util.Scanner; </li></ul></li><li>创建该类对象（声明变量） <ul><li>Scanner myScanner = new Scanner(System.in);</li></ul></li><li>调用里面的功能<ul><li>字符串：如 String name = myScanner.next();</li><li>整型：如 int num = myScanner.nextInt();</li><li>以此类推…</li></ul></li></ul></li></ul><h2 id="十、进制-程序员的基本功）"><a href="#十、进制-程序员的基本功）" class="headerlink" title="十、进制(程序员的基本功）"></a>十、进制(程序员的基本功）</h2><ul><li><p>对于整数，有四种表示方式： </p><ul><li>二进制：0,1 ，满 2 进 1.以 0b 或 0B 开头。 </li><li>十进制：0-9 ，满 10 进 1。 </li><li>八进制：0-7 ，满 8 进 1. 以数字 0 开头表示。</li><li>十六进制：0-9 及 A(10)-F(15)，满 16 进 1. 以 0x 或 0X 开头表示。此处的 A-F 不区分大小写。</li></ul></li><li><p><strong>二进制、八进制、十六进制 转 十进制</strong></p><ul><li> 二进制转换成十进制</li><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228171456468.png" alt="image-20230228171456468"></li><li>八进制转换成十进制<ul><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228171635324.png" alt="image-20230228171635324"></li></ul></li><li>十六进制转换成十进制<ul><li>规则：从最低位(右边)开始，将每个位上的数提取出来，乘以 16 的(位数-1)次方，然后求和。</li><li>案例：请将 0x23A 转成十进制的数 </li><li>0x23A = 10 * 16^0 + 3 * 16 ^ 1 + 2 * 16^2 = 10 + 48 + 512 = 570</li></ul></li></ul></li><li><p><strong>十进制 转 二进制、八进制、十六进制</strong></p><ul><li> 十进制转换成二进制</li><li>规则：将该数不断除以 2，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的二进制。</li><li>案例：请将 34 转成二进制 = 0B00100010</li><li><img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228173038160.png" alt="image-20230228173038160"></li><li> 十进制转换成八进制</li><li> 规则：将该数不断除以 8，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的八进制。</li><li> 案例：请将 131 转成八进制 =&gt; 0203</li><li> <img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228183244615.png" alt="image-20230228183244615"></li><li> 十进制转换成十六进制</li><li> 规则：将该数不断除以 16，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的十六进制。</li><li> 案例：请将 237 转成十六进制 =&gt; 0xED</li><li> <img src="https://cdn.staticaly.com/gh/jiangliang-7/markdown_pic@main/2023/2/image-20230228183348496.png" alt="image-20230228183348496"></li></ul></li><li><p><strong>二进制 转 八进制、十六进制</strong></p><ul><li>二进制转换成八进制<ul><li>规则：从低位开始,将二进制数每三位一组，转成对应的八进制数即可。 </li><li>案例：请将 ob11010101 转成八进制</li><li>ob11(3)010(2)101(5) =&gt; 0325</li></ul></li><li>二进制转换成十六进制<ul><li>规则：从低位开始，将二进制数每四位一组，转成对应的十六进制数即可。</li><li>案例：请将 ob11010101 转成十六进制 </li><li>ob1101(D)0101(5) = 0xD5</li></ul></li></ul></li><li><p><strong>八进制、十六进制 转 二进制</strong></p><ul><li>八进制转换成二进制<ul><li>规则：将八进制数每 1 位，转成对应的一个 3 位的二进制数即可。 </li><li>案例：请将 0237 转成二进制 </li><li>02(010)3(011)7(111) = 0b10011111</li></ul></li><li>十六进制转换成二进制<ul><li>规则：将十六进制数每 1 位，转成对应的 4 位的一个二进制数即可。 </li><li>案例：请将 0x23B 转成二进制 </li><li>0x2(0010)3(0011)B(1011) = 0b001000111011</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="java笔记" scheme="https://jiangliang-7.github.io/categories/java%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://jiangliang-7.github.io/tags/java/"/>
    
  </entry>
  
</feed>
